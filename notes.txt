Les exceptions : C'est avoir un plan B quand quelque chose peut mal se passer
Les d√©corateurs : C'est ajouter des super-pouvoirs √† tes fonctions sans les modifier
Ces deux concepts te permettent d'√©crire du code plus robuste et plus propre !

üö® La gestion des exceptions (les erreurs)
Le probl√®me
Imagine que tu √©cris un programme qui doit ouvrir un fichier sur ton ordinateur. 
Mais si le fichier n'existe pas, ton programme va planter compl√®tement et s'arr√™ter. 
C'est comme si tu essayais d'ouvrir une porte qui n'existe pas - √ßa ne marche pas !

La solution : try/except
C'est comme avoir un plan B ! Tu dis √† ton programme : "Essaie de faire √ßa, mais si √ßa marche pas, fais √ßa √† la place."

# Sans protection (le programme plante)
with open("fichier_inexistant.txt") as f:
    print(f.read())
print("Cette ligne ne s'affichera jamais si le fichier n'existe pas")

# Avec protection (le programme continue)
try:
    with open("fichier_inexistant.txt") as f:
        print(f.read())
except Exception as e:
    print("Oups, le fichier n'existe pas !")
print("Cette ligne s'affichera quand m√™me")

Ne compte pas sur les erreurs pour g√©rer ton programme ! 
C'est mieux de v√©rifier avant :

import os
if os.path.isfile("fichier.txt"):  # Je v√©rifie d'abord si le fichier existe
    with open("fichier.txt") as f:
        print(f.read())


üé≠ Les d√©corateurs de fonctions
C'est quoi ?
Un d√©corateur, c'est comme un emballage cadeau pour tes fonctions. 
Il ajoute des fonctionnalit√©s suppl√©mentaires sans modifier la fonction originale.
Exemple concret : mesurer le temps
Imagine que tu veux savoir combien de temps prend chacune de tes fonctions :

Sans d√©corateur (r√©p√©titif et p√©nible)
import time

def ma_fonction():
    print("Je fais quelque chose...")
    time.sleep(2)

# √Ä chaque fois, je dois √©crire √ßa :
start = time.time()
ma_fonction()
end = time.time()
print(f"Temps : {end - start}s")


Avec un d√©corateur (magique !)
def chronometer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        func(*args, **kwargs)  # J'ex√©cute la vraie fonction
        end = time.time()
        print(f"Temps d'ex√©cution : {end - start:.3f}s")
    return wrapper

@chronometer  # Je "d√©core" ma fonction
def ma_fonction():
    print("Je fais quelque chose...")
    time.sleep(2)

# Maintenant, le temps s'affiche automatiquement !
ma_fonction()
Comment √ßa marche ?

Le @chronometer dit : "Quand quelqu'un appelle ma_fonction(), passe d'abord par chronometer"
chronometer cr√©e une fonction wrapper qui fait le travail suppl√©mentaire (mesurer le temps)
wrapper appelle ta vraie fonction au milieu
C'est comme un sandwich : temps ‚Üí ta fonction ‚Üí temps

Avec des param√®tres
Si ta fonction a besoin de param√®tres, pas de probl√®me :
@chronometer
def dire_bonjour(nom, age):
    print(f"Bonjour {nom}, tu as {age} ans !")

dire_bonjour("Alice", 16)  # Les param√®tres passent √† travers le d√©corateur
